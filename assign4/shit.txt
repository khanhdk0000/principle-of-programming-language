'''
 *   @author Nguyen Hua Phung
 *   @version 1.0
 *   23/10/2015
 *   This file provides a simple version of code generator
 *
'''
from Visitor import BaseVisitor
from Emitter import Emitter
from Frame import Frame
from abc import ABC, abstractmethod
from AST import * 

class MethodEnv():
    def __init__(self, frame, sym):
        self.frame = frame
        self.sym = sym
class Symbol:
    def __init__(self,name,mtype,value = None):
        self.name = name
        self.mtype = mtype
        self.value = value
class CName:
    def __init__(self,n):
        self.value = n
class Index:
    def __init__(self,n):
        self.value = n
class Type(ABC): pass
class IntType(Type): pass
class FloatType(Type): pass
class VoidType(Type): pass
class ClassType(Type):
    def __init__(self,n):
        self.cname = n
class StringType(Type):pass
class BoolType(Type): pass
class Unknown(Type): pass
class MType(Type):
    def __init__(self,i,o):
        self.partype = i #List[Type]
        self.rettype = o #Type	
class ArrayType(Type):
    def __init__(self,et,*s):
        self.eleType = et #Type
        self.dimen = s   #List[int]  

class Access():
    def __init__(self,frame,sym,isLeft,checkArr = False):
        self.frame = frame
        self.sym = sym
        self.isLeft = isLeft
        self.checkArr = checkArr

class CodeGenerator():
    def __init__(self):
        self.libName = "io"

    def init(self):
        return [Symbol("read", MType([], StringType()), CName(self.libName)),
                Symbol("printLn", MType([], VoidType()), CName(self.libName)),
                Symbol("printStrLn", MType([StringType()], VoidType()), CName(self.libName)),
                Symbol("print", MType([StringType()], VoidType()), CName(self.libName)),
		        Symbol("string_of_int", MType([IntType()], StringType()), CName(self.libName)),
                Symbol("string_of_float", MType([FloatType()], StringType()), CName(self.libName)),
                Symbol("int_of_float", MType([FloatType()], IntType()), CName(self.libName)),
                Symbol("float_to_int", MType([IntType()], FloatType()), CName(self.libName)),
                Symbol("int_of_string", MType([StringType()], IntType()), CName(self.libName)),
                Symbol("bool_of_string", MType([StringType()], BoolType()), CName(self.libName)),
                Symbol("string_of_bool", MType([BoolType()], StringType()), CName(self.libName)),
                Symbol("float_of_string", MType([StringType()], FloatType()), CName(self.libName))
                ]

    def gen(self, ast, dir_):
        #ast: AST
        #dir_: String

        gl = self.init()
        gc = CodeGenVisitor(ast, gl, dir_)
        gc.visit(ast, None)



class CodeGenVisitor(BaseVisitor):
    def __init__(self, astTree, env, dir_):
        #astTree: AST
        #env: List[Symbol]
        #dir_: File

        self.astTree = astTree
        self.env = env
        self.className = "MCClass"
        self.path = dir_
        self.emit = Emitter(self.path + "/" + self.className + ".j")
        self.inf = [] #infer type
        self.ret = Unknown() #return type
        self.printBuff = [] #print buffer
        self.paramType = Unknown()
    
    def printout(self,ast,c):
        for ele in self.printBuff:
            # print(ele)
            self.emit.printout(ele)
        self.printBuff = []

    def visitProgram(self, ast, c):
        #ast: Program
        #c: Any
        var = []
        init= []
        self.emit.printout(self.emit.emitPROLOG(self.className, "java.lang.Object"))
        for x in ast.decl:
            if isinstance(x,VarDecl):
                init = init+ [x]
                var = var + [x.accept(self,None)]
        self.genCl(init) # init global
        for x in ast.decl:
            if isinstance(x,FuncDecl):
                var = var + [Symbol(x.name.name,MType([Unknown() for i in x.param],Unknown()),CName(self.className))]

        var = var + self.env
        # for sym in var:
            # print(str(sym.name) + str(sym.mtype.rettype))
        for x in ast.decl:
            if isinstance(x,FuncDecl):
                x.accept(self,Access(None,var,False))
        #
        
        e = MethodEnv(None, self.env)
        # self.genMain(e)
        # generate default constructor
        self.genInit()

        # generate class init if necessary

        # print("BUF: " + str(self.emit.buff))
        self.emit.emitEPILOG()
        return c
    def visitVarDecl(self,ast,c):

        va  = ast.variable.accept(self,None)
        init = ast.varInit.accept(self,None) if ast.varInit else self.paramType
        # print("IN: "+str(init))
        if c== None:
            
            cname = CName(self.className)
            jas = self.emit.emitATTRIBUTE(va,init,False,None)

            self.emit.printout(jas)
            return Symbol(va,init,cname)
        else:
            
            idx = c.frame.getNewIndex()
            s_label = c.frame.getStartLabel()
            e_label = c.frame.getEndLabel()
            jas = self.emit.emitVAR(idx,va,init,s_label,e_label,c.frame)
            self.printBuff.append(jas)
            j= ""
            if isinstance(ast.varDimen,list) and ast.varDimen != [] and ast.varInit:
                # self.printBuff.append(self.emit.emitArr(init,c.frame))
                # print("B: " + str(self.printBuff))
                a = MethodEnv(c.frame,[])
                i,it = ast.varInit.accept(self,a) #return [str])
                s = self.emit.emitArr(init,c.frame) + self.emit.emitDUP(c.frame)
                self.printBuff.append(self.assignArr("",init,a.sym,c))
                self.printBuff.append(self.emit.emitWRITEVAR(va,init,idx,c.frame))
            elif ast.varInit:
                j,t = ast.varInit.accept(self,MethodEnv(c.frame,[]))
                j = j +  self.emit.emitWRITEVAR(va,t,idx,c.frame)
                self.printBuff.append(j)
            else:
                return Symbol(va,init,Index(idx))     
            
            # print(self.printBuff)
            return Symbol(va,init,Index(idx))     
    def assignArr(self,res,arr,init,c):
        # print(str(arr))
        # print("R: "+str(res))
        if isinstance(arr,ArrayType):
            res = res + self.emit.emitArr(arr,c.frame)
            res = res + self.emit.emitDUP(c.frame)
        
        for i in range(arr.dimen[0]):
            res = res+self.emit.emitPUSHCONST(i,IntType(),c.frame)
            # print("A: "+str(arr.eleType))
            if isinstance(arr.eleType,ArrayType):
                # res = res+self.emit.emitPUSHCONST(arr.eleType.dimen[0],IntType(),c.frame)
                res = self.assignArr(res,arr.eleType,init,c)
            else:
                res = res + init.pop(0) + self.emit.emitASTORE(arr.eleType,c.frame)
            if isinstance(arr.eleType,ArrayType):
                res = res + self.emit.emitASTORE(arr.eleType,c.frame)
            if i< arr.dimen[0] -1:
                res = res + self.emit.emitDUP(c.frame)
            
        # print("R: "+str(res))
        return res



    def visitFuncDecl(self,ast,c): 
        
        for ele in c.sym:
            if ast.name.name == ele.name:
                sym = ele
                break
        isMain = sym.name == "main"
        # print("isMain: "+ str(isMain))
        
        frame = Frame(sym.name,VoidType)
        
        frame.enterScope(False if any(isinstance(x,Return) and (x.expr!= None) for x in ast.body[1]) else True) 
        if isMain: 
            varname = "args"
            vartype = ArrayType(StringType())
            varindex = frame.getNewIndex()
            # print("ID:  "+str(varindex))
        startLabel, endLabel = frame.getStartLabel(), frame.getEndLabel()
       
        # print("S: "+str(sym.name))

        symList =[]
        i=0
        for ele in ast.param:
            self.paramType = sym.mtype.partype[i]
            symList = [ele.accept(self,Access(frame,c.sym,False))] + symList
            i = i +1
        paraList = [ele.name for ele in symList]
        # print("P: " + str(paraList))    

        for ele in ast.body[0]:
            # print(ele)
            symList = [ele.accept(self,Access(frame,c.sym,False))] + symList

        
        symList = symList+ c.sym
        # print("List: ")
        # for ele in symList:
        #     print(ele.name)

        self.ret = sym.mtype.rettype
        for ele in ast.body[1]:
            ele.accept(self,Access(frame,symList,False))
                
        if isinstance(sym.mtype.rettype,Unknown):
            sym.mtype.rettype = self.ret if isinstance(self.ret,Unknown)==False else VoidType()
        i = len(sym.mtype.partype) -1
        for ele in symList:
            if ele.name in paraList:
                sym.mtype.partype[i] = ele.mtype 
                i = i-1
        # print("S: "+str(sym.mtype.partype))
            

        methodname = sym.name
        methodtype = sym.mtype if isMain == False else MType([ArrayType(StringType())],VoidType())
        # print("Me: " + str(methodname))
        # print("T: "+ str(methodtype.partype))
        self.emit.printout(self.emit.emitMETHOD(methodname,methodtype,True,frame))
        if isMain:
            self.emit.printout(self.emit.emitVAR(varindex, varname, vartype, startLabel, endLabel,frame ))    
        self.emit.printout(self.emit.emitLABEL(startLabel,frame))
        self.printout(ast,frame)
        self.emit.printout(self.emit.emitLABEL(endLabel, frame))
        if any(isinstance(ele,Return) for ele in ast.body[1])==False:
            if isinstance(sym.mtype.rettype,(Unknown,VoidType)):
                sym.mtype.rettype = VoidType()
                self.emit.printout(self.emit.emitRETURN(VoidType(), frame))
            else:
                self.emit.printout(self.emit.emitPUSHCONST('0.0' if isinstance(sym.mtype.rettype,FloatType) else '0',sym.mtype.rettype,frame))
                self.emit.printout(self.emit.emitRETURN(sym.mtype.rettype, frame))
        # print("B: " + str(frame.getMaxIndex()))

        self.emit.printout(self.emit.emitENDMETHOD(frame))
        frame.exitScope()

    def call(self,ast,c,isStmt):
        # print(ast.method.name)
        # print("INF: "+str(self.inf))
        for ele in c.sym:
            # print(ele.name)
            if ast.method.name == ele.name:
                sym = ele
                break
        if isinstance(sym.mtype.rettype,Unknown):
            if isinstance(sym.mtype.rettype,Unknown):
                sym.mtype.rettype = self.inf[0]
        # print("Pop: "+str(self.inf[0]))
        self.inf.pop(0)
        paramCode = ""
        i =0 
        for ele in ast.param:
            # print("ele: " +str(ele))
            if isinstance(ele,(CallExpr,Id)) and isinstance(sym.mtype.partype[i],Unknown)==False:
                p = self.infer(ast,ele,None,sym.mtype.partype[i],c)
            else:

                p, pt  = ele.accept(self,Access(c.frame,c.sym,False))
            if isinstance(sym.mtype.partype[i],Unknown):
                sym.mtype.partype[i] = pt
            # print("P: "+str(p))
            paramCode = paramCode + p
            i = i+1

        # print("R: "+str(sym.mtype.partype))
        # print("N: "+str(sym.value.value + '/' + sym.name))
        jas = paramCode 
        jas = jas +self.emit.emitINVOKESTATIC(sym.value.value + '/' + sym.name, sym.mtype, c.frame)
        if isStmt:
            self.printBuff.append(jas)
        else:
            return jas, sym.mtype.rettype


    def visitCallStmt(self,ast,c):
        self.inf.insert(0,VoidType())
        return self.call(ast,c,True)

    def visitReturn(self,ast,c):
        if ast.expr == None:
            self.ret = VoidType()
            self.printBuff.append(self.emit.emitRETURN(VoidType(),c.frame) )
            return 
        else:
            if isinstance(self.ret,Unknown) == False and isinstance(ast.expr,CallExpr):
                self.inf.insert(0,self.ret)

            ex,et = ast.expr.accept(self,Access(c.frame,c.sym,False))
            self.printBuff.append(ex)
            self.printBuff.append(self.emit.emitRETURN(et,c.frame) )
            self.ret = et
            # print(self.ret)


    def visitAssign(self,ast,c): 
        # print("Visit Assign")
        if isinstance(ast.lhs,(CallExpr,Id)):
            self.inf.insert(0,None)
        isArr,typ  = ast.lhs.accept(self,Access(c.frame,c.sym,True,True))
        if isArr: pass
            # [frame.push() for i in range(0,2)]
        if isinstance(ast.rhs,(CallExpr,Id)):
            self.inf.insert(0,typ)
        r,rt = ast.rhs.accept(self,Access(c.frame,c.sym,False))
        if isinstance(ast.lhs,(CallExpr,Id)):
            self.inf.insert(0,rt)
        l,lt = ast.lhs.accept(self,Access(c.frame,c.sym,True))

        if isArr:
            self.printBuff.append(l[0] + r  + l[1])
            # [frame.pop() for i in range(0,2)]
        else:
            self.printBuff.append(r+l)

    def visitArrayCell(self,ast,c):
        if c.checkArr== True and c.isLeft==True:
            if isinstance(ast.arr,Id):
                ar,at = ast.arr.accept(self,Access(c.frame,c.sym,True,True))
                return True,at
        ar,at = ast.arr.accept(self,Access(c.frame,c.sym,False)) #load arrref
        # print("A: "+str(ar))
        # at = self.getType(at)
       
        
        idxCode = ""
        j = 0
        #load until index
        for ele in ast.idx:
            if isinstance(ele,(CallExpr,Id)):
                self.inf.insert(0,IntType)
            i,it = ele.accept(self,Access(c.frame,c.sym,False))
            at = at.eleType
            idxCode = idxCode + i 
            idxCode = idxCode + self.emit.emitALOAD(ArrayType(at),c.frame) if j<len(ast.idx) -1 else idxCode
            
            j = j+1
            
        #     # idxCode = idxCode + self.emit.emitPUSHICONST(at) + self.emit.emitADDOP('-',IntType(),c.frame) #?
         # print("T: "+str(at))
        # print(idxCode)
        if c.isLeft:
            return [ar + idxCode, self.emit.emitASTORE(at,c.frame)],at
        else:
            return ar + idxCode + self.emit.emitALOAD(at,c.frame), at 

        
        

        

    def visitCallExpr(self,ast,c):
        return self.call(ast,c,False)

    def visitBinaryOp(self,ast,c):
        l = ast.left
        r = ast.right
        if ast.op in ['+','-','*','\\','%']:
            l,r = self.infer(ast, l, r, IntType(), c)   
        elif ast.op in ['+.','-.','*.','\.']:
            l,r = self.infer(ast, l, r, FloatType(), c) 
        elif ast.op in ['==','!=','<','>','<=','>=']:
            l,r = self.infer(ast, l, r, IntType(), c)
        elif ast.op in ['!','&&','||']:
            l,r = self.infer(ast, l, r, BoolType(), c)
        elif ast.op in ['=/=','<.','>.','<=.','>=.']:
            l,r = self.infer(ast, l, r, FloatType(), c)

        rType = None
        if ast.op in ['+','-']:
            jas = self.emit.emitADDOP(ast.op,IntType(),c.frame)
            rtype = IntType()
        elif ast.op in ['*','\\']:
            jas = self.emit.emitMULOP(ast.op,IntType(),c.frame)
            rtype = IntType()
        elif ast.op in ['%']:
            jas = self.emit.emitMOD(c.frame)
            rtype = IntType()
        elif ast.op in ['+.','-.']:
            jas = self.emit.emitADDOP(ast.op[0],FloatType(),c.frame)
            rtype = FloatType()
        elif ast.op in ['*.','\.']:
            jas = self.emit.emitMULOP(ast.op[0],FloatType(),c.frame)
            rtype = FloatType()
        elif ast.op in ['&&']:
            jas = self.emit.emitANDOP(c.frame)
            rtype = BoolType()
        elif ast.op in ['||']:
            jas = self.emit.emitOROP(c.frame)
            rtype = BoolType()
        elif ast.op in ['==','!=','<','>','<=','>=']:
            jas = self.emit.emitREOP(ast.op,IntType(),c.frame)
            rtype = BoolType()
        elif ast.op in ['=/=','<.','>.','<=.','>=.']:
            jas = self.emit.emitREOP(ast.op,FloatType(),c.frame)
            rtype = BoolType()

        else:
            pass
        
        return l + r + jas, rtype

    def visitUnaryOp(self,ast,c):
        ex = ast.body
        if ast.op == '-':
            ex = self.infer(ast,ex,None,IntType(),c)
            jas = self.emit.emitNEGOP(IntType(),c.frame)
            rtype = IntType()
        elif ast.op == '-.':
            ex = self.infer(ast,ex,None,FloatType(),c)
            jas = self.emit.emitNEGOP(FloatType(),c.frame)
            rtype = FloatType()
        elif ast.op == '!':
            ex = self.infer(ast,ex,None,BoolType(),c)
            jas = self.emit.emitNOT(BoolType(),c.frame)
            rtype = BoolType()

        return  ex + jas, rtype
        
    def infer(self,ast,ex1,ex2,typ,c):
        if isinstance(ex1,(CallExpr,Id)):
            self.inf.insert(0,typ)
        l,_ = ex1.accept(self,Access(c.frame,c.sym,False))
        if ex2 == None:
            return l 
        if isinstance(ex2,(CallExpr,Id)):
            self.inf.insert(0,typ)
        r,_ = ex2.accept(self,Access(c.frame,c.sym,False))
        return l,r

    def visitId(self,ast,c):
        if c==None:
            # print("ID: "+str(ast.name))
            return ast.name
       
        for ele in c.sym:
            if ast.name == ele.name:
                sym = ele
                break
        # print("F: "+str(self.inf))
        if self.inf != [] and self.inf[0] != None:
            if isinstance(sym.mtype,Unknown):
                sym.mtype = self.inf.pop()
        else:
            if self.inf!= []:
                self.inf.pop()
        # print("INF: " +str(sym.mtype))
        if c.checkArr== True and c.isLeft==True:
            return False, sym.mtype
        # print(sym.name)
        # print(sym.mtype.eleType.eleType)

        #push frame for arr
        if isinstance(sym.mtype,ArrayType):
            temp = sym.mtype
            while(isinstance(temp,ArrayType)):
                c.frame.push()
                c.frame.push()
                temp = temp.eleType

        if isinstance(sym.value,CName):
            j = self.emit.emitGETSTATIC(sym.value.value + '/' + sym.name, sym.mtype,c.frame) if c.isLeft == False else self.emit.emitPUTSTATIC(sym.value.value + '/' + sym.name, sym.mtype,c.frame)
        else:
            j = self.emit.emitREADVAR(sym.name,sym.mtype,sym.value.value,c.frame) if c.isLeft == False else  self.emit.emitWRITEVAR(sym.name,sym.mtype,sym.value.value,c.frame)

        #pop frame for arr
        if isinstance(sym.mtype,ArrayType):
            temp = sym.mtype
            while(isinstance(temp,ArrayType)):
                c.frame.pop()
                c.frame.pop()
                temp = temp.eleType   

        return j, sym.mtype

    def visitIf(self,ast,c):

        endLabel = c.frame.getNewLabel()
        for stm in ast.ifthenStmt:
            nextLabel = c.frame.getNewLabel()
            if isinstance(stm[0],(CallExpr,Id)):
                self.inf.insert(0,BoolType())
            ex,et = stm[0].accept(self,Access(c.frame,c.sym,False))
            self.printBuff.append(ex + self.emit.emitIFFALSE(nextLabel,c.frame))
            self.visitStmtList(ast,(stm[1],stm[2]),c)
            self.printBuff.append(self.emit.emitGOTO(endLabel,c.frame))
            self.printBuff.append(self.emit.emitLABEL(nextLabel,c.frame))
        if ast.elseStmt != None:
            self.visitStmtList(ast,ast.elseStmt,c)
        self.printBuff.append(self.emit.emitLABEL(endLabel,c.frame))



    def visitWhile(self,ast,c):
        c.frame.enterLoop()
        conLabel = c.frame.getContinueLabel()
        brkLabel = c.frame.getBreakLabel()
        if isinstance(ast.exp,(CallExpr,Id)):
            self.inf.insert(0,BoolType())
        ex,et = ast.exp.accept(self,Access(c.frame,c.sym,False))
        self.printBuff.append(self.emit.emitLABEL(conLabel,c.frame))
        self.printBuff.append(ex + self.emit.emitIFFALSE(brkLabel,c.frame))
        self.visitStmtList(ast,ast.sl,c)
        self.printBuff.append(self.emit.emitGOTO(conLabel,c.frame))
        self.printBuff.append(self.emit.emitLABEL(brkLabel,c.frame))
        c.frame.exitLoop()
        
    def visitDowhile(self,ast,c):
        c.frame.enterLoop()
        conLabel = c.frame.getContinueLabel()
        brkLabel = c.frame.getBreakLabel()
        if isinstance(ast.exp,(CallExpr,Id)):
            self.inf.insert(0,BoolType())
        ex,et = ast.exp.accept(self,Access(c.frame,c.sym,False))
        self.printBuff.append(self.emit.emitLABEL(conLabel,c.frame))
        self.visitStmtList(ast,ast.sl,c)
        self.printBuff.append(ex + self.emit.emitIFFALSE(brkLabel,c.frame))
        self.printBuff.append(self.emit.emitGOTO(conLabel,c.frame))
        self.printBuff.append(self.emit.emitLABEL(brkLabel,c.frame))
        c.frame.exitLoop()

    def visitFor(self,ast,c):
        if isinstance(ast.expr1,(CallExpr,Id)):
            self.inf.insert(0,IntType())
        r,rt = ast.expr1.accept(self,Access(c.frame,c.sym,False))
        if isinstance(ast.idx1,(CallExpr,Id)):
            self.inf.insert(0,IntType())
        l,lt = ast.idx1.accept(self,Access(c.frame,c.sym,True))
        self.printBuff.append(r+l)

        c.frame.enterLoop()
        strLabel = c.frame.getNewLabel()
        conLabel = c.frame.getContinueLabel()
        brkLabel = c.frame.getBreakLabel()
        if isinstance(ast.expr2,(CallExpr,Id)):
            self.inf.insert(0,BoolType())
        ex,et = ast.expr2.accept(self,Access(c.frame,c.sym,False))
        self.printBuff.append(self.emit.emitLABEL(strLabel,c.frame))
        self.printBuff.append(ex + self.emit.emitIFFALSE(brkLabel,c.frame))
        self.visitStmtList(ast,ast.loop,c)
        self.printBuff.append(self.emit.emitLABEL(conLabel,c.frame))
        if isinstance(ast.expr3,(CallExpr,Id)):
            self.inf.insert(0,IntType())
        e,et = ast.expr3.accept(self,Access(c.frame,c.sym,False))
        l,lt = ast.idx1.accept(self,Access(c.frame,c.sym,False))
        self.printBuff.append(e + l + self.emit.emitADDOP('+',lt,c.frame))
        if isinstance(ast.idx1,(CallExpr,Id)):
            self.inf.insert(0,IntType())
        i,it = ast.idx1.accept(self,Access(c.frame,c.sym,True))
        self.printBuff.append(i)
        self.printBuff.append(self.emit.emitGOTO(strLabel,c.frame))
        self.printBuff.append(self.emit.emitLABEL(brkLabel,c.frame))
        c.frame.exitLoop()

    def visitStmtList(self,ast,li,c):
        symList = c.sym
        c.frame.enterScope(False)
        self.printBuff.append(self.emit.emitLABEL(c.frame.getStartLabel(),c.frame))
        for ele in li[0]:
            symList =  [ele.accept(self,Access(c.frame,c.sym,False))] + symList
        for ele in li[1]:
            ele.accept(self,Access(c.frame,symList,False))
        self.printBuff.append(self.emit.emitLABEL(c.frame.getEndLabel(),c.frame))
        c.frame.exitScope()

    def visitIntLiteral(self,ast,c):
        if c == None:
            return IntType()
        jas  = self.emit.emitPUSHCONST(ast.value,IntType(),c.frame)
        return jas, IntType()
    def visitFloatLiteral(self,ast,c):
        if c == None:
            return FloatType()
        jas  = self.emit.emitPUSHCONST(str(ast.value),FloatType(),c.frame)
        return jas, FloatType()
    def visitBooleanLiteral(self,ast,c):
        if c == None:
            return BoolType()
        jas  = self.emit.emitPUSHCONST(ast.value,BoolType(),c.frame)
        return jas, BoolType()
    def visitStringLiteral(self,ast,c):
        if c == None:
            return StringType()

        jas  = self.emit.emitPUSHCONST(str(ast.value),StringType(),c.frame)
        # print("J: ")
        # print(jas)
        return jas, StringType()
    def visitArrayLiteral(self,ast,c):
        #c.isLeft: output str
        a = self.getArr(ast,c)
        if c == None:
            return a
        else:
            for ele in ast.value:
                # self.printBuff.append(self.emit.emitDUP(c.frame))
                # self.printBuff.append(self.emit.emitPUSHCONST(i,IntType(),c.frame))
                # print(ele)
                s,st = ele.accept(self,c)
                if isinstance(ele,ArrayLiteral)==False:
                    c.sym.append(s)

            # print("O: "+str(c.sym))
        return a, self.getType(a)






    def getArr(self,ast,c):
        # print("A: "+str(ast))
        if isinstance(ast.value[0],ArrayLiteral) == False:
            # print(ast.value[0])
            r = ArrayType(ast.value[0].accept(self,None),len(ast.value))
            return  r 
        r = ArrayType(self.getArr(ast.value[0],c),len(ast.value))
        return r

    def getType(self,arr):
        if isinstance(arr,ArrayType) == False:
            return arr
        return self.getType(arr.eleType)



    def visitContinue(self,ast,c):
        l = c.frame.getContinueLabel()
        self.printBuff.append(self.emit.emitGOTO(l,c.frame) )
    
    def visitBreak(self,ast,c):
        l = c.frame.getBreakLabel()
        self.printBuff.append(self.emit.emitGOTO(l,c.frame) )

    def genInit(self):
        methodname,methodtype = "<init>",MType([],VoidType())
        frame = Frame(methodname, methodtype.rettype)
        self.emit.printout(self.emit.emitMETHOD(methodname,methodtype,False,frame))
        frame.enterScope(True)
        varname,vartype,varindex = "this",ClassType(self.className),frame.getNewIndex()
        startLabel, endLabel = frame.getStartLabel(), frame.getEndLabel()
        self.emit.printout(self.emit.emitVAR(varindex, varname, vartype, startLabel, endLabel,frame ))
        self.emit.printout(self.emit.emitLABEL(startLabel,frame))
        self.emit.printout(self.emit.emitREADVAR(varname, vartype, varindex, frame))
        self.emit.printout(self.emit.emitINVOKESPECIAL(frame))
        self.emit.printout(self.emit.emitLABEL(endLabel, frame))
        self.emit.printout(self.emit.emitRETURN(methodtype.rettype, frame))
        self.emit.printout(self.emit.emitENDMETHOD(frame))

    # The following code is just for initial, students should remove it and write your visitor from here
    def genMain(self,o):
        methodname,methodtype = "main",MType([ArrayType(StringType())],VoidType())
        frame = Frame(methodname, methodtype.rettype)
        self.emit.printout(self.emit.emitMETHOD(methodname,methodtype,True,frame))
        frame.enterScope(True)
        varname,vartype,varindex = "args",methodtype.partype[0],frame.getNewIndex()
        startLabel, endLabel = frame.getStartLabel(), frame.getEndLabel()
        self.emit.printout(self.emit.emitVAR(varindex, varname, vartype, startLabel, endLabel,frame ))
        self.emit.printout(self.emit.emitLABEL(startLabel,frame))
        self.emit.printout(self.emit.emitPUSHICONST(120, frame))
        sym = next(filter(lambda x: x.name == "string_of_int",o.sym))
        self.emit.printout(self.emit.emitINVOKESTATIC(sym.value.value+"/string_of_int",sym.mtype,frame))
        sym = next(filter(lambda x: x.name == "print",o.sym))
        self.emit.printout(self.emit.emitINVOKESTATIC(sym.value.value+"/print",sym.mtype,frame))
        self.emit.printout(self.emit.emitLABEL(endLabel, frame))
        self.emit.printout(self.emit.emitRETURN(methodtype.rettype, frame))
        self.emit.printout(self.emit.emitENDMETHOD(frame))
        frame.exitScope()
        # exitScope

    def genCl(self, var_list):
        methodname,methodtype = "<clinit>",MType([],VoidType())
        frame = Frame(methodname, methodtype.rettype)
        self.emit.printout(self.emit.emitMETHOD(methodname,methodtype,True,frame))
        frame.enterScope(True)
        startLabel, endLabel = frame.getStartLabel(), frame.getEndLabel()
        self.emit.printout(self.emit.emitLABEL(startLabel,frame))

        def assign(ast):
                if isinstance(ast.varDimen,list) and ast.varDimen != [] and ast.varInit:
                    a = MethodEnv(frame,[])
                    arr,typ = ast.varInit.accept(self,a) #return [str])
                    # print("J: " +str(jas) + str(typ))
                    s = self.emit.emitArr(arr,frame) + self.emit.emitDUP(frame)
                    jas = self.assignArr("",arr,a.sym,MethodEnv(frame,None))
                    put = self.emit.emitPUTSTATIC(self.className + '/' + ast.variable.name,arr,frame)
                else:
                    jas , typ = ast.varInit.accept(self,MethodEnv(frame,None))
                    put = self.emit.emitPUTSTATIC(self.className + '/' + ast.variable.name,typ,frame)
                # print(jas+put)
                self.emit.printout(jas + put)
        for ele in var_list:
            # print("ELE: "+str(ele))
            assign(ele)
        self.emit.printout(self.emit.emitLABEL(endLabel, frame))
        self.emit.printout(self.emit.emitRETURN(methodtype.rettype, frame))
        self.emit.printout(self.emit.emitENDMETHOD(frame))


from MachineCode import JasminCode
import CodeGenerator as cgen

class Emitter():
    def __init__(self, filename):
        self.filename = filename
        self.buff = list()
        self.jvm = JasminCode()

    def getJVMType(self, inType):
        
        typeIn = type(inType)
        if typeIn in [cgen.IntType,cgen.Unknown]:
            return "I"
        elif typeIn is cgen.FloatType:
            return "F"
        elif typeIn is cgen.StringType:
            return "Ljava/lang/String;"
        elif typeIn is cgen.BoolType:
            return "Z"
        elif typeIn is cgen.VoidType:
            return "V"
        elif typeIn is cgen.ArrayType:
            return "[" + self.getJVMType(inType.eleType)
        elif typeIn is cgen.MType:
           
            return "(" + "".join(list(map(lambda x: self.getJVMType(x), inType.partype))) + ")" + self.getJVMType(inType.rettype)
        elif typeIn is cgen.ClassType:
            return "L" + inType.cname + ";"

    def getFullType(self,inType):
        typeIn = type(inType)
        if typeIn is cgen.IntType:
            return "int"
        elif typeIn is cgen.FloatType:
            return "float"
        elif typeIn is cgen.BoolType:
            return "boolean"
        elif typeIn is cgen.StringType:
            return "java/lang/String;"
        elif typeIn is cgen.VoidType:
            return "void"

    def emitPUSHICONST(self, in_, frame):
        #in: Int or Sring
        #frame: Frame
        
        frame.push();
        if type(in_) is int:
            i = in_
            if i >= -1 and i <=5:
                return self.jvm.emitICONST(i)
            elif i >= -128 and i <= 127:
                return self.jvm.emitBIPUSH(i)
            elif i >= -32768 and i <= 32767:
                return self.jvm.emitSIPUSH(i)
        elif type(in_) is str:
            if in_ == "True":
                return self.emitPUSHICONST(1, frame)
            elif in_ == "False":
                return self.emitPUSHICONST(0, frame)
            else:
                return self.emitPUSHICONST(int(in_), frame)

    def emitPUSHFCONST(self, in_, frame):
        #in_: String
        #frame: Frame
        f = float(in_)
        frame.push()
        rst = "{0:.4f}".format(f)
        if rst == "0.0" or rst == "1.0" or rst == "2.0":
            return self.jvm.emitFCONST(rst)
        else:
            return self.jvm.emitLDC(in_)           

    ''' 
    *    generate code to push a constant onto the operand stack.
    *    @param in the lexeme of the constant
    *    @param typ the type of the constant
    '''
    def emitPUSHCONST(self, in_, typ, frame):
        #in_: String
        #typ: Type
        #frame: Frame
        
        if type(typ) is cgen.IntType:
            return self.emitPUSHICONST(in_, frame)
        elif type(typ) is cgen.FloatType:
            return self.emitPUSHFCONST(in_, frame)
        elif type(typ) is cgen.BoolType:
            b = 1 if in_ == "True" else 0
            return self.emitPUSHICONST(b, frame)
        elif type(typ) is cgen.StringType:
            frame.push()
            return self.jvm.emitLDC(in_)
        else:
            raise IllegalOperandException(in_)

    ##############################################################

    def emitALOAD(self, in_, frame):
        #in_: Type
        #frame: Frame
        #..., arrayref, index, value -> ...
        
        frame.pop()
        if type(in_) is cgen.IntType:
            return self.jvm.emitIALOAD()
        elif type(in_) is cgen.FloatType:
            return self.jvm.emitFALOAD()
        elif type(in_) is cgen.BoolType:
            return self.jvm.emitBALOAD()
        elif type(in_) is cgen.ArrayType or type(in_) is cgen.ClassType or type(in_) is cgen.StringType:
            return self.jvm.emitAALOAD()
        else:
            raise IllegalOperandException(str(in_))

    def emitASTORE(self, in_, frame):
        #in_: Type
        #frame: Frame
        #..., arrayref, index, value -> ...
        
        frame.pop()
        frame.pop()
        frame.pop()
        if type(in_) is cgen.IntType:
            return self.jvm.emitIASTORE()
        if type(in_) is cgen.FloatType:
            return self.jvm.emitFASTORE()
        if type(in_) is cgen.BoolType:
            return self.jvm.emitBASTORE()
        elif type(in_) is cgen.ArrayType or type(in_) is cgen.ClassType or type(in_) is cgen.StringType:
            return self.jvm.emitAASTORE()
        else:
            raise IllegalOperandException(str(in_))

    '''    generate the var directive for a local variable.
    *   @param in the index of the local variable.
    *   @param varName the name of the local variable.
    *   @param inType the type of the local variable.
    *   @param fromLabel the starting label of the scope where the variable is active.
    *   @param toLabel the ending label  of the scope where the variable is active.
    '''
    def emitVAR(self, in_, varName, inType, fromLabel, toLabel, frame):
        #in_: Int
        #varName: String
        #inType: Type
        #fromLabel: Int
        #toLabel: Int
        #frame: Frame
        
        return self.jvm.emitVAR(in_, varName, self.getJVMType(inType), fromLabel, toLabel)

    def emitREADVAR(self, name, inType, index, frame):
        #name: String
        #inType: Type
        #index: Int
        #frame: Frame
        #... -> ..., value
        
        frame.push()
        if type(inType) in [cgen.IntType,cgen.BoolType]:
            return self.jvm.emitILOAD(index)
        elif type(inType) is cgen.FloatType:
            return self.jvm.emitFLOAD(index)
        elif type(inType) is cgen.ArrayType or type(inType) is cgen.ClassType or type(inType) is cgen.StringType:
            return self.jvm.emitALOAD(index)
        else:
            raise IllegalOperandException(name)

    ''' generate the second instruction for array cell access
    *
    '''
    def emitREADVAR2(self, name, typ, frame):
        #name: String
        #typ: Type
        #frame: Frame
        #... -> ..., value

        #frame.push()
        raise IllegalOperandException(name)

    '''
    *   generate code to pop a value on top of the operand stack and store it to a block-scoped variable.
    *   @param name the symbol entry of the variable.
    '''
    def emitWRITEVAR(self, name, inType, index, frame):
        #name: String
        #inType: Type
        #index: Int
        #frame: Frame
        #..., value -> ...
        
        frame.pop()

        if type(inType) in [cgen.IntType,cgen.BoolType]:
            return self.jvm.emitISTORE(index)
        elif type(inType) is cgen.FloatType:
            return self.jvm.emitFSTORE(index)
        elif type(inType) is cgen.ArrayType or type(inType) is cgen.ClassType or type(inType) is cgen.StringType:
            return self.jvm.emitASTORE(index)
        else:
            raise IllegalOperandException(name)

    ''' generate the second instruction for array cell access
    *
    '''
    def emitWRITEVAR2(self, name, typ, frame):
        #name: String
        #typ: Type
        #frame: Frame
        #..., value -> ...

        #frame.push()
        raise IllegalOperandException(name)

    ''' generate the field (static) directive for a class mutable or immutable attribute.
    *   @param lexeme the name of the attribute.
    *   @param in the type of the attribute.
    *   @param isFinal true in case of constant; false otherwise
    '''
    def emitATTRIBUTE(self, lexeme, in_, isFinal, value = None):
        #lexeme: String
        #in_: Type
        #isFinal: Boolean
        #value: String

        return self.jvm.emitSTATICFIELD(lexeme, self.getJVMType(in_), False)

    def emitGETSTATIC(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame

        frame.push()
        return self.jvm.emitGETSTATIC(lexeme, self.getJVMType(in_))

    def emitPUTSTATIC(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame
        
        frame.pop()
        return self.jvm.emitPUTSTATIC(lexeme, self.getJVMType(in_))

    def emitGETFIELD(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame

        return self.jvm.emitGETFIELD(lexeme, self.getJVMType(in_))

    def emitPUTFIELD(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame

        frame.pop()
        frame.pop()
        return self.jvm.emitPUTFIELD(lexeme, self.getJVMType(in_))

    ''' generate code to invoke a static method
    *   @param lexeme the qualified name of the method(i.e., class-name/method-name)
    *   @param in the type deor of the method.
    '''
    def emitINVOKESTATIC(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame
        typ = in_
        list(map(lambda x: frame.pop(), typ.partype))

        if not type(typ.rettype) is cgen.VoidType:
            frame.push()
       
        return self.jvm.emitINVOKESTATIC(lexeme, self.getJVMType(in_))

    ''' generate code to invoke a special method
    *   @param lexeme the qualified name of the method(i.e., class-name/method-name)
    *   @param in the type deor of the method.
    '''
    def emitINVOKESPECIAL(self, frame, lexeme=None, in_=None):
        #lexeme: String
        #in_: Type
        #frame: Frame

        if not lexeme is None and not in_ is None:
            typ = in_
            list(map(lambda x: frame.pop(), typ.partype))
            frame.pop()
            if not type(typ.rettype) is cgen.VoidType:
                frame.push()
            return self.jvm.emitINVOKESPECIAL(lexeme, self.getJVMType(in_))
        elif lexeme is None and in_ is None:
            frame.pop()
            return self.jvm.emitINVOKESPECIAL()

    ''' generate code to invoke a virtual method
    * @param lexeme the qualified name of the method(i.e., class-name/method-name)
    * @param in the type deor of the method.
    '''
    def emitINVOKEVIRTUAL(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame

        typ = in_
        list(map(lambda x: frame.pop(), typ.partype))
        frame.pop()
        if not type(typ) is cgen.VoidType:
            frame.push()
        return self.jvm.emitINVOKEVIRTUAL(lexeme, self.getJVMType(in_))

    '''
    *   generate ineg, fneg.
    *   @param in the type of the operands.
    '''
    def emitNEGOP(self, in_, frame):
        #in_: Type
        #frame: Frame
        #..., value -> ..., result

        if type(in_) is cgen.IntType:
            return self.jvm.emitINEG()
        else:
            return self.jvm.emitFNEG()

    def emitNOT(self, in_, frame):
        #in_: Type
        #frame: Frame

        label1 = frame.getNewLabel()
        label2 = frame.getNewLabel()
        result = list()
        result.append(self.emitIFTRUE(label1, frame))
        result.append(self.emitPUSHCONST("True", in_, frame))
        result.append(self.emitGOTO(label2, frame))
        result.append(self.emitLABEL(label1, frame))
        result.append(self.emitPUSHCONST("False", in_, frame))
        result.append(self.emitLABEL(label2, frame))
        return ''.join(result)

    '''
    *   generate iadd, isub, fadd or fsub.
    *   @param lexeme the lexeme of the operator.
    *   @param in the type of the operands.
    '''
    def emitADDOP(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame
        #..., value1, value2 -> ..., result

        frame.pop()
        if lexeme == "+":
            if type(in_) is cgen.IntType:
                return self.jvm.emitIADD()
            else:
                return self.jvm.emitFADD()
        else:
            if type(in_) is cgen.IntType:
                return self.jvm.emitISUB()
            else:
                return self.jvm.emitFSUB()

    '''
    *   generate imul, idiv, fmul or fdiv.
    *   @param lexeme the lexeme of the operator.
    *   @param in the type of the operands.
    '''

    def emitMULOP(self, lexeme, in_, frame):
        #lexeme: String
        #in_: Type
        #frame: Frame
        #..., value1, value2 -> ..., result

        frame.pop()
        if lexeme == "*":
            if type(in_) is cgen.IntType:
                return self.jvm.emitIMUL()
            else:
                return self.jvm.emitFMUL()
        else:
            if type(in_) is cgen.IntType:
                return self.jvm.emitIDIV()
            else:
                return self.jvm.emitFDIV()

    def emitDIV(self, frame):
        #frame: Frame

        frame.pop()
        return self.jvm.emitIDIV()

    def emitMOD(self, frame):
        #frame: Frame

        frame.pop()
        return self.jvm.emitIREM()

    '''
    *   generate iand
    '''

    def emitANDOP(self, frame):
        #frame: Frame

        frame.pop()
        return self.jvm.emitIAND()

    '''
    *   generate ior
    '''
    def emitOROP(self, frame):
        #frame: Frame

        frame.pop()
        return self.jvm.emitIOR()

    def emitREOP(self, op, in_, frame):
        #op: String
        #in_: Type
        #frame: Frame
        #..., value1, value2 -> ..., result

        result = list()
        labelF = frame.getNewLabel()
        labelO = frame.getNewLabel()

        frame.pop()
        frame.pop()
        f= False
        if type(in_) is cgen.FloatType:
            f =True
            result.append(self.jvm.emitFCMPL()) #-1< 0= 1>
        if op in['>','>.']:
            if f:
                result.append(self.jvm.emitIFLE(labelF))
            else:
                result.append(self.jvm.emitIFICMPLE(labelF))
        elif op in['>=','>=.']:
            if f:
                result.append(self.jvm.emitIFLT(labelF))
            else:
                result.append(self.jvm.emitIFICMPLT(labelF))   
        elif op in['<','<.']:
            if f:
                result.append(self.jvm.emitIFGE(labelF))
            else:
                result.append(self.jvm.emitIFICMPGE(labelF))  
        elif op in['<=','<=.']:
            if f:
                result.append(self.jvm.emitIFGT(labelF))
            else:
                result.append(self.jvm.emitIFICMPGT(labelF)) 
        elif op in['!=','=/=']:
            if f:
                result.append(self.jvm.emitIFEQ(labelF))
            else:
                result.append(self.jvm.emitIFICMPEQ(labelF))
        else: #==
            if f:
                result.append(self.jvm.emitIFNE(labelF))
            else:
                result.append(self.jvm.emitIFICMPNE(labelF))

        result.append(self.emitPUSHCONST("1", cgen.IntType(), frame))
        frame.pop()
        result.append(self.emitGOTO(labelO, frame))
        result.append(self.emitLABEL(labelF, frame))
        result.append(self.emitPUSHCONST("0", cgen.IntType(), frame))
        result.append(self.emitLABEL(labelO, frame))
        return ''.join(result)

    def emitRELOP(self, op, in_, trueLabel, falseLabel, frame):
        #op: String
        #in_: Type
        #trueLabel: Int
        #falseLabel: Int
        #frame: Frame
        #..., value1, value2 -> ..., result

        result = list()

        frame.pop()
        frame.pop()
        if op == ">":
            result.append(self.jvm.emitIFICMPLE(falseLabel))
            result.append(self.emitGOTO(trueLabel))
        elif op == ">=":
            result.append(self.jvm.emitIFICMPLT(falseLabel))
        elif op == "<":
            result.append(self.jvm.emitIFICMPGE(falseLabel))
        elif op == "<=":
            result.append(self.jvm.emitIFICMPGT(falseLabel))
        elif op == "!=":
            result.append(self.jvm.emitIFICMPEQ(falseLabel))
        elif op == "==":
            result.append(self.jvm.emitIFICMPNE(falseLabel))
        result.append(self.jvm.emitGOTO(trueLabel))
        return ''.join(result)

    '''   generate the method directive for a function.
    *   @param lexeme the qualified name of the method(i.e., class-name/method-name).
    *   @param in the type deor of the method.
    *   @param isStatic <code>true</code> if the method is static; <code>false</code> otherwise.
    '''

    def emitMETHOD(self, lexeme, in_, isStatic, frame):
        #lexeme: String
        #in_: Type
        #isStatic: Boolean
        #frame: Frame

        return self.jvm.emitMETHOD(lexeme, self.getJVMType(in_), isStatic)

    '''   generate the end directive for a function.
    '''
    def emitENDMETHOD(self, frame):
        #frame: Frame

        buffer = list()
        buffer.append(self.jvm.emitLIMITSTACK(frame.getMaxOpStackSize()))
        buffer.append(self.jvm.emitLIMITLOCAL(frame.getMaxIndex()))
        buffer.append(self.jvm.emitENDMETHOD())
        return ''.join(buffer)

    def getConst(self, ast):
        #ast: Literal
        if type(ast) is IntLiteral:
            return (str(ast.value), cgen.IntType())

    '''   generate code to initialize a local array variable.<p>
    *   @param index the index of the local variable.
    *   @param in the type of the local array variable.
    '''
    # def emitGlobalArr(self,ast,arr,frame):
    #     d = 0
    #     res = []
    #     temp = arr
    #     while(isinstance(temp,cgen.ArrayType)):
    #         print(temp.dimen)
    #         res.append(self.emitPUSHICONST(temp.dimen[0],frame))
    #         d = d + 1
    #         temp = temp.eleType
    #     res.append(self.jvm.emitMULTIANEWARRAY(self.getJVMType(arr),str(d)))
    #     print("R: " +str(res) )
    #     return ''.join(res)

    
    def emitArr(self,arr,frame):
        res = []
        res.append(self.emitPUSHICONST(arr.dimen[0],frame))
        if isinstance(arr.eleType,(cgen.ArrayType,cgen.ClassType)):
            res.append(self.jvm.emitANEWARRAY(self.getJVMType(arr.eleType)))
        elif isinstance(arr.eleType,cgen.StringType):
            res.append(self.jvm.emitANEWARRAY('java/lang/String'))
        else:
            res.append(self.jvm.emitNEWARRAY(self.getFullType(arr.eleType)))
        return ''.join(res)


    '''   generate code to initialize local array variables.
    *   @param in the list of symbol entries corresponding to local array variable.    
    '''

    '''   generate code to jump to label if the value on top of operand stack is true.<p>
    *   ifgt label
    *   @param label the label where the execution continues if the value on top of stack is true.
    '''
    def emitIFTRUE(self, label, frame):
        #label: Int
        #frame: Frame

        frame.pop()
        return self.jvm.emitIFGT(label)

    '''
    *   generate code to jump to label if the value on top of operand stack is false.<p>
    *   ifle label
    *   @param label the label where the execution continues if the value on top of stack is false.
    '''
    def emitIFFALSE(self, label, frame):
        #label: Int
        #frame: Frame

        frame.pop()
        return self.jvm.emitIFLE(label)

    def emitIFICMPGT(self, label, frame):
        #label: Int
        #frame: Frame

        frame.pop()
        return self.jvm.emitIFICMPGT(label)

    def emitIFICMPLT(self, label, frame):
        #label: Int
        #frame: Frame

        frame.pop()
        return self.jvm.emitIFICMPLT(label)    

    '''   generate code to duplicate the value on the top of the operand stack.<p>
    *   Stack:<p>
    *   Before: ...,value1<p>
    *   After:  ...,value1,value1<p>
    '''
    def emitDUP(self, frame):
        #frame: Frame

        frame.push()
        return self.jvm.emitDUP()

    def emitPOP(self, frame):
        #frame: Frame

        frame.pop()
        return self.jvm.emitPOP()

    '''   generate code to exchange an integer on top of stack to a floating-point number.
    '''
    def emitI2F(self, frame):
        #frame: Frame

        return self.jvm.emitI2F()

    ''' generate code to return.
    *   <ul>
    *   <li>ireturn if the type is IntegerType or BooleanType
    *   <li>freturn if the type is RealType
    *   <li>return if the type is null
    *   </ul>
    *   @param in the type of the returned expression.
    '''

    def emitRETURN(self, in_, frame):
        #in_: Type
        #frame: Frame

        if type(in_) in [cgen.IntType,cgen.BoolType]:
            frame.pop()
            return self.jvm.emitIRETURN()
        elif type(in_) is cgen.FloatType:
            frame.pop()
            return self.jvm.emitFRETURN()
        elif type(in_) is cgen.VoidType:
            return self.jvm.emitRETURN()
        else: 
            frame.pop()
            return self.jvm.emitARETURN()

    ''' generate code that represents a label	
    *   @param label the label
    *   @return code Label<label>:
    '''
    def emitLABEL(self, label, frame):
        #label: Int
        #frame: Frame

        return self.jvm.emitLABEL(label)

    ''' generate code to jump to a label	
    *   @param label the label
    *   @return code goto Label<label>
    '''
    def emitGOTO(self, label, frame):
        #label: Int
        #frame: Frame

        return self.jvm.emitGOTO(label)

    ''' generate some starting directives for a class.<p>
    *   .source MPC.CLASSNAME.java<p>
    *   .class public MPC.CLASSNAME<p>
    *   .super java/lang/Object<p>
    '''
    def emitPROLOG(self, name, parent):
        #name: String
        #parent: String

        result = list()
        result.append(self.jvm.emitSOURCE(name + ".java"))
        result.append(self.jvm.emitCLASS("public " + name))
        result.append(self.jvm.emitSUPER("java/land/Object" if parent == "" else parent))
        return ''.join(result)

    def emitLIMITSTACK(self, num):
        #num: Int

        return self.jvm.emitLIMITSTACK(num)

    def emitLIMITLOCAL(self, num):
        #num: Int

        return self.jvm.emitLIMITLOCAL(num)

    def emitEPILOG(self):
        file = open(self.filename, "w")
        file.write(''.join(self.buff))
        file.close()

    ''' print out the code to screen
    *   @param in the code to be printed out
    '''
    def printout(self, in_):
        #in_: String

        self.buff.append(in_)

    def clearBuff(self):
        self.buff.clear()





        

    
